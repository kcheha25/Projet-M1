resolution_nm_per_pixel = 0.038
image_dir = 'images'
gt_mask_dir = 'masks'

# Configurer le modèle Detectron2
cfg = get_cfg()
cfg.merge_from_file(model_zoo.get_config_file("COCO-InstanceSegmentation/mask_rcnn_R_50_FPN_3x.yaml"))
cfg.MODEL.WEIGHTS = 'path_to_your_detectron2_model.pth'  # Chemin vers ton modèle Detectron2
cfg.MODEL.ROI_HEADS.SCORE_THRESH_TEST = 0.5  # Seuillage pour les détections
cfg.MODEL.DEVICE = 'cuda' if torch.cuda.is_available() else 'cpu'

predictor = DefaultPredictor(cfg)

# Fonction pour calculer les aires en nanomètres
def calculate_area(mask):
    if mask.ndim == 3:
        mask = mask[..., 0]  # Convertir en 2D si nécessaire
    _, binary_mask = cv2.threshold(mask, 0.5, 1, cv2.THRESH_BINARY)
    binary_mask = (binary_mask * 255).astype(np.uint8)
    
    num_objects, object_labels = cv2.connectedComponents(binary_mask)
    areas = []
    for obj in range(1, num_objects):
        area_pixels = np.sum(object_labels == obj)
        area_nm = area_pixels * (resolution_nm_per_pixel ** 2)
        areas.append(area_nm)
    return areas

# Fonction pour normaliser les comptages d'objets
def normalize_counts(counts):
    total_count = sum(counts)
    return [count / total_count for count in counts] if total_count > 0 else counts

# Fonction pour afficher l'histogramme en barres
def plot_histogram(test_areas, gt_areas, prefix):
    fig, axs = plt.subplots(1, 2, figsize=(12, 6))
    axs[0].bar(range(len(test_areas)), normalize_counts(test_areas))
    axs[0].set_title(f"Prédictions du modèle pour le groupe {prefix}")
    axs[0].set_xlabel("Surface en nanomètres")
    axs[0].set_ylabel("Nombre d'objets détectés (normalisé)")

    axs[1].bar(range(len(gt_areas)), normalize_counts(gt_areas))
    axs[1].set_title(f"Masques de vérité terrain pour le groupe {prefix}")
    axs[1].set_xlabel("Surface en nanomètres")
    axs[1].set_ylabel("Nombre d'objets détectés (normalisé)")

    plt.tight_layout()
    plt.show()

# Dictionnaire pour accumuler les aires par préfixe d'image
predicted_areas_by_prefix = {}
gt_areas_by_prefix = {}

# Boucle sur chaque image
for image_file in sorted(os.listdir(image_dir)):
    prefix = image_file[:6]
    
    # Charger l'image et le masque de vérité terrain
    image = io.imread(os.path.join(image_dir, image_file))
    gt_file = image_file.replace('image', 'mask')
    gt_mask = io.imread(os.path.join(gt_mask_dir, gt_file))

    # Assurez-vous que le masque de vérité terrain est binaire
    if gt_mask.ndim == 3:
        gt_mask = gt_mask[..., 0]
    gt_mask = (gt_mask > 0).astype(np.uint8)

    # Effectuer une prédiction avec Detectron2
    outputs = predictor(image)
    pred_mask = outputs["instances"].pred_masks[0].cpu().numpy() if outputs["instances"].pred_masks else np.zeros_like(gt_mask)

    # Calcul des aires pour le masque prédit et le masque de vérité terrain
    pred_areas = calculate_area(pred_mask)
    gt_areas = calculate_area(gt_mask)

    # Accumuler les aires pour chaque groupe de préfixe
    if prefix not in predicted_areas_by_prefix:
        predicted_areas_by_prefix[prefix] = []
        gt_areas_by_prefix[prefix] = []
        
    predicted_areas_by_prefix[prefix].extend(pred_areas)
    gt_areas_by_prefix[prefix].extend(gt_areas)

# Afficher les histogrammes pour chaque groupe d'images ayant le même préfixe
for prefix in predicted_areas_by_prefix:
    plot_histogram(predicted_areas_by_prefix[prefix], gt_areas_by_prefix[prefix], prefix)