import tensorflow as tf
import numpy as np
import matplotlib.pyplot as plt
from skimage import io
import os

# Paramètres
resolution_nm_per_pixel = 0.038
image_dir = 'images'
gt_mask_dir = 'masks'

# Charger le modèle U-Net
model = tf.keras.models.load_model('path_to_your_unet_model')

# Fonction pour calculer les aires en nanomètres
def calculate_area(mask):
    # Compter les pixels de chaque objet détecté
    num_objects, object_labels = cv2.connectedComponents(mask.astype(np.uint8))
    areas = []
    for obj in range(1, num_objects):
        area_pixels = np.sum(object_labels == obj)
        area_nm = area_pixels * (resolution_nm_per_pixel ** 2)
        areas.append(area_nm)
    return areas

# Fonction pour normaliser les comptages d'objets
def normalize_counts(counts):
    total_count = sum(counts)
    return [count / total_count for count in counts] if total_count > 0 else counts

# Fonction pour afficher l'histogramme en barres
def plot_histogram(test_areas, gt_areas, prefix):
    fig, axs = plt.subplots(1, 2, figsize=(12, 6))
    axs[0].bar(range(len(test_areas)), normalize_counts(test_areas))
    axs[0].set_title(f"Prédictions du modèle pour le groupe {prefix}")
    axs[0].set_xlabel("Surface en nanomètres")
    axs[0].set_ylabel("Nombre d'objets détectés (normalisé)")

    axs[1].bar(range(len(gt_areas)), normalize_counts(gt_areas))
    axs[1].set_title(f"Masques de vérité terrain pour le groupe {prefix}")
    axs[1].set_xlabel("Surface en nanomètres")
    axs[1].set_ylabel("Nombre d'objets détectés (normalisé)")

    plt.tight_layout()
    plt.show()

# Dictionnaire pour accumuler les aires par préfixe d'image
predicted_areas_by_prefix = {}
gt_areas_by_prefix = {}

# Boucle sur chaque image
for image_file in sorted(os.listdir(image_dir)):
    prefix = image_file[:6]  # Extraire le préfixe (6 premiers caractères)
    
    # Charger et préparer l'image et le masque de vérité terrain
    image = io.imread(os.path.join(image_dir, image_file))
    gt_file = image_file.replace('image', 'mask')  # Assumer que le nom du masque correspond au fichier image
    gt_mask = io.imread(os.path.join(gt_mask_dir, gt_file))

    # Redimensionner l'image pour correspondre aux dimensions d'entrée du modèle
    image_input = np.expand_dims(image, axis=0)
    
    # Prédire le masque
    pred_mask = model.predict(image_input)[0]  # Extraire la première prédiction du lot

    # Calcul des aires pour le masque prédit et le masque de vérité terrain
    pred_areas = calculate_area(pred_mask)
    gt_areas = calculate_area(gt_mask)
    
    # Accumuler les aires pour chaque groupe de préfixe
    if prefix not in predicted_areas_by_prefix:
        predicted_areas_by_prefix[prefix] = []
        gt_areas_by_prefix[prefix] = []
        
    predicted_areas_by_prefix[prefix].extend(pred_areas)
    gt_areas_by_prefix[prefix].extend(gt_areas)

# Afficher les histogrammes pour chaque groupe d'images ayant le même préfixe
for prefix in predicted_areas_by_prefix:
    plot_histogram(predicted_areas_by_prefix[prefix], gt_areas_by_prefix[prefix], prefix)
