import tensorflow as tf
import numpy as np
import matplotlib.pyplot as plt
from skimage import io
import os
import cv2

# Paramètres
resolution_nm_per_pixel = 0.038
diameter_bins = np.arange(0, 2.1, 0.1)  # Plages de diamètre de 0.1 nm jusqu'à 2 nm
image_dir = 'images'
gt_mask_dir = 'masks'

# Charger le modèle U-Net
model = tf.keras.models.load_model('path_to_your_unet_model')

# Fonction pour calculer les diamètres à partir des aires en nanomètres
def calculate_diameters(mask):
    if mask.ndim == 3:
        mask = mask[..., 0]
    _, binary_mask = cv2.threshold(mask, 0.5, 1, cv2.THRESH_BINARY)
    binary_mask = (binary_mask * 255).astype(np.uint8)
    
    num_objects, object_labels = cv2.connectedComponents(binary_mask)
    diameters = []
    for obj in range(1, num_objects):
        area_pixels = np.sum(object_labels == obj)
        area_nm2 = area_pixels * (resolution_nm_per_pixel ** 2)
        diameter = 2 * np.sqrt(area_nm2 / np.pi)  # Convertir l'aire en diamètre (nm)
        diameters.append(diameter)
    return diameters

# Fonction pour calculer la fréquence normalisée des diamètres
def normalize_diameter_frequencies(diameters, bins):
    counts, _ = np.histogram(diameters, bins=bins)
    total_count = np.sum(counts)
    normalized_frequencies = counts / total_count if total_count > 0 else counts
    return normalized_frequencies

# Calcul des ratios NP/total et de l'axe y pour chaque groupe
def calculate_plot_ratios(diameters_by_prefix):
    x_values, y_values = [], []
    
    for prefix, diameters in diameters_by_prefix.items():
        freqs = normalize_diameter_frequencies(diameters, diameter_bins)
        
        # Calcul de NP / Total pour les diamètres > 0.5 nm
        index_above_05 = diameter_bins[:-1] > 0.5
        NP = freqs[index_above_05].sum()  # Somme des fréquences normalisées pour diamètres > 0.5 nm
        Total = freqs.sum()  # Somme de toutes les fréquences normalisées
        NP_total_ratio = NP / Total if Total > 0 else 0
        
        # Calcul de la valeur y
        y_sum = 0
        for i, freq in enumerate(freqs):
            if diameter_bins[i] > 0.5:
                median = np.median(diameter_bins[i:i + 2])  # Calculer la médiane pour la plage
                y_sum += freq / median
        
        y_value = y_sum / NP if NP > 0 else 0  # Diviser la somme par NP

        x_values.append(NP_total_ratio)
        y_values.append(y_value)
        
    return x_values, y_values

# Dictionnaire pour stocker les diamètres par groupe
diameters_by_prefix = {}

# Boucle sur chaque image
for image_file in sorted(os.listdir(image_dir)):
    prefix = image_file[:6]
    image = io.imread(os.path.join(image_dir, image_file))
    gt_file = image_file.replace('image', 'mask')
    gt_mask = io.imread(os.path.join(gt_mask_dir, gt_file))

    if gt_mask.ndim == 3:
        gt_mask = gt_mask[..., 0]
    gt_mask = (gt_mask > 0).astype(np.uint8)

    # Redimensionner l'image et prédire le masque
    image_input = np.expand_dims(image, axis=0)
    pred_mask = model.predict(image_input)[0]
    if pred_mask.ndim == 3:
        pred_mask = pred_mask[..., 0]

    pred_diameters = calculate_diameters(pred_mask)
    
    # Accumuler les diamètres pour chaque préfixe
    if prefix not in diameters_by_prefix:
        diameters_by_prefix[prefix] = []
    diameters_by_prefix[prefix].extend(pred_diameters)

# Calculer les ratios NP/Total et valeurs y pour chaque groupe
x_vals, y_vals = calculate_plot_ratios(diameters_by_prefix)

# Dessiner le nuage de points
plt.figure(figsize=(10, 6))
for i, prefix in enumerate(diameters_by_prefix.keys()):
    plt.scatter(x_vals[i], y_vals[i], label=prefix, s=100)  # chaque point est un groupe

plt.xlabel("Rapport NP / Total")
plt.ylabel("Valeur normalisée / NP pour diamètres > 0.5 nm")
plt.legend(title="Groupes d'images")
plt.title("Nuage de points des fréquences normalisées par diamètre")
plt.show()
