import os
import numpy as np
import matplotlib.pyplot as plt
from skimage import measure, io
from scipy import ndimage
from tensorflow.keras.models import load_model

# Charger le modèle
model = load_model("unet_membrane.hdf5")

# Chemins vers les dossiers d'images et de masques de vérité terrain
image_dir = "path/to/test_images"  # Remplace par le chemin vers les images de test
gt_mask_dir = "path/to/ground_truth_masks"  # Remplace par le chemin vers les masques de vérité terrain

# Fonction pour calculer la surface et le diamètre des objets dans un masque
def calculate_properties(mask):
    labeled_mask, num_features = ndimage.label(mask)
    regions = measure.regionprops(labeled_mask)
    areas = [region.area for region in regions]
    diameters = [np.sqrt(area / np.pi) * 2 for area in areas]  # Diamètre = 2 * sqrt(Area / pi)
    return areas, diameters

# Dictionnaires pour stocker les résultats
results_pred = {}
results_gt = {}

# Charger et traiter chaque image
image_files = sorted(os.listdir(image_dir))
gt_files = sorted(os.listdir(gt_mask_dir))

for image_file, gt_file in zip(image_files, gt_files):
    # Charger l'image et le masque de vérité terrain
    image = io.imread(os.path.join(image_dir, image_file))
    gt_mask = io.imread(os.path.join(gt_mask_dir, gt_file))
    
    # Redimensionner l'image si nécessaire pour correspondre aux dimensions d'entrée du modèle
    image_input = np.expand_dims(image, axis=0)
    
    # Prédire le masque
    pred_mask = model.predict(image_input)
    pred_mask = pred_mask.squeeze()  # Suppression de la dimension supplémentaire
    
    # Binarisation des masques
    pred_mask_bin = (pred_mask > 0.5).astype(np.uint8)
    gt_mask_bin = (gt_mask > 0.5).astype(np.uint8)
    
    # Calculer les propriétés des masques prédits
    areas_pred, diameters_pred = calculate_properties(pred_mask_bin)
    
    # Calculer les propriétés des masques de vérité terrain
    areas_gt, diameters_gt = calculate_properties(gt_mask_bin)
    
    # Identifier le prefix des noms d'image pour regrouper
    prefix = image_file[:6]
    
    # Résultats pour les masques prédits
    if prefix not in results_pred:
        results_pred[prefix] = {
            'isolated_atoms_freq': 0,
            'clusters_freq': 0,
            'nanoparticles_freq': 0,
            'mean_diameter': 0,
            'total_nanoparticles': 0,
        }

    # Classifier les objets dans les masques prédits
    for d, f in zip(diameters_pred, np.ones(len(diameters_pred))):  # Fréquence ici initialisée à 1
        if d < 0.2:
            results_pred[prefix]['isolated_atoms_freq'] += f
        elif 0.2 <= d <= 0.5:
            results_pred[prefix]['clusters_freq'] += f
        elif d > 0.5:
            results_pred[prefix]['nanoparticles_freq'] += f
            results_pred[prefix]['mean_diameter'] += d * f
            results_pred[prefix]['total_nanoparticles'] += f
            
    # Calculer le diamètre moyen des nanoparticules
    if results_pred[prefix]['nanoparticles_freq'] > 0:
        results_pred[prefix]['mean_diameter'] /= results_pred[prefix]['nanoparticles_freq']
        
    # Résultats pour les masques de vérité terrain
    if prefix not in results_gt:
        results_gt[prefix] = {
            'isolated_atoms_freq': 0,
            'clusters_freq': 0,
            'nanoparticles_freq': 0,
            'mean_diameter': 0,
            'total_nanoparticles': 0,
        }

    # Classifier les objets dans les masques de vérité terrain
    for d, f in zip(diameters_gt, np.ones(len(diameters_gt))):  # Fréquence ici initialisée à 1
        if d < 0.2:
            results_gt[prefix]['isolated_atoms_freq'] += f
        elif 0.2 <= d <= 0.5:
            results_gt[prefix]['clusters_freq'] += f
        elif d > 0.5:
            results_gt[prefix]['nanoparticles_freq'] += f
            results_gt[prefix]['mean_diameter'] += d * f
            results_gt[prefix]['total_nanoparticles'] += f
            
    # Calculer le diamètre moyen des nanoparticules
    if results_gt[prefix]['nanoparticles_freq'] > 0:
        results_gt[prefix]['mean_diameter'] /= results_gt[prefix]['nanoparticles_freq']

# Préparer les données pour les nuages de points
x_values_pred = []
y_values_pred = []
x_values_gt = []
y_values_gt = []

# Liste des symboles pour chaque préfixe
symbols = ['o', 's', '^', 'D', 'P', '*', 'x', '+']  # Cercle, carré, triangle, losange, pentagone, étoile, 'x', '+'

prefix_list = list(results_pred.keys())
prefix_symbol_map = {prefix: symbols[i % len(symbols)] for i, prefix in enumerate(prefix_list)}

for prefix in results_pred.keys():
    if results_pred[prefix]['isolated_atoms_freq'] > 0:
        ratio_pred = results_pred[prefix]['nanoparticles_freq'] / results_pred[prefix]['isolated_atoms_freq']
        x_values_pred.append(ratio_pred)
        y_values_pred.append(results_pred[prefix]['mean_diameter'])
        
for prefix in results_gt.keys():
    if results_gt[prefix]['isolated_atoms_freq'] > 0:
        ratio_gt = results_gt[prefix]['nanoparticles_freq'] / results_gt[prefix]['isolated_atoms_freq']
        x_values_gt.append(ratio_gt)
        y_values_gt.append(results_gt[prefix]['mean_diameter'])

# Affichage des nuages de points
plt.figure(figsize=(12, 6))

# Nuage de points pour les masques prédits
plt.subplot(1, 2, 1)
for prefix in results_pred.keys():
    if results_pred[prefix]['isolated_atoms_freq'] > 0:
        plt.scatter(
            results_pred[prefix]['nanoparticles_freq'] / results_pred[prefix]['isolated_atoms_freq'],
            results_pred[prefix]['mean_diameter'],
            label=prefix,
            marker=prefix_symbol_map[prefix],
            s=100  # Taille des symboles
        )

plt.title("Diamètre moyen des NP - Masques Prédits")
plt.xlabel("Rapport de fréquences NP/atomes isolés")
plt.ylabel("Diamètre moyen des nanoparticules (nm)")
plt.grid()
plt.legend()

# Nuage de points pour les masques de vérité terrain
plt.subplot(1, 2, 2)
for prefix in results_gt.keys():
    if results_gt[prefix]['isolated_atoms_freq'] > 0:
        plt.scatter(
            results_gt[prefix]['nanoparticles_freq'] / results_gt[prefix]['isolated_atoms_freq'],
            results_gt[prefix]['mean_diameter'],
            label=prefix,
            marker=prefix_symbol_map[prefix],
            s=100  # Taille des symboles
        )

plt.title("Diamètre moyen des NP - Ground Truth")
plt.xlabel("Rapport de fréquences NP/atomes isolés")
plt.ylabel("Diamètre moyen des nanoparticules (nm)")
plt.grid()
plt.legend()

plt.tight_layout()
plt.show()
