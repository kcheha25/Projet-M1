import tensorflow as tf
import numpy as np
import matplotlib.pyplot as plt
import cv2
import os
from collections import defaultdict

# Paramètres
resolution_nm_per_pixel = 0.038
image_folder = 'images'
mask_folder = 'masks'

# Charger le modèle U-Net
model = tf.keras.models.load_model('path_to_your_unet_model')

def load_images(folder):
    images = {}
    for filename in sorted(os.listdir(folder)):
        prefix = filename[:6]  # Extraire le préfixe (6 premiers caractères)
        img_path = os.path.join(folder, filename)
        img = cv2.imread(img_path, cv2.IMREAD_GRAYSCALE)  # Lire en niveaux de gris
        img = cv2.resize(img, (256, 256))  # Ajuster la taille si nécessaire
        if prefix not in images:
            images[prefix] = []
        images[prefix].append(img)
    return images

# Charger les images de test et les masques de vérité terrain, groupés par préfixe
test_images = load_images(image_folder)
ground_truth_masks = load_images(mask_folder)

# Prédire les masques et organiser les résultats par préfixe
predicted_masks_by_prefix = {}
for prefix, images in test_images.items():
    images = np.array(images)
    predicted_masks_by_prefix[prefix] = model.predict(images)

def calculate_area(mask):
    # Compter les pixels de chaque objet détecté
    num_objects, object_labels = cv2.connectedComponents(mask.astype(np.uint8))
    areas = []
    for obj in range(1, num_objects):
        area_pixels = np.sum(object_labels == obj)
        area_nm = area_pixels * (resolution_nm_per_pixel ** 2)
        areas.append(area_nm)
    return areas

def normalize_counts(counts):
    total_count = sum(counts)
    return [count / total_count for count in counts] if total_count > 0 else counts

def plot_histogram(test_areas, gt_areas, prefix):
    fig, axs = plt.subplots(1, 2, figsize=(12, 6))
    axs[0].bar(range(len(test_areas)), normalize_counts(test_areas))
    axs[0].set_title(f"Prédictions du modèle pour le groupe {prefix}")
    axs[0].set_xlabel("Surface en nanomètres")
    axs[0].set_ylabel("Nombre d'objets détectés (normalisé)")

    axs[1].bar(range(len(gt_areas)), normalize_counts(gt_areas))
    axs[1].set_title(f"Masques de vérité terrain pour le groupe {prefix}")
    axs[1].set_xlabel("Surface en nanomètres")
    axs[1].set_ylabel("Nombre d'objets détectés (normalisé)")

    plt.tight_layout()
    plt.show()

# Calculer et afficher les histogrammes pour chaque groupe d'images
for prefix, pred_masks in predicted_masks_by_prefix.items():
    test_areas = []
    gt_areas = []

    # Accumuler les surfaces pour toutes les images d'un même groupe
    for pred_mask, gt_mask in zip(pred_masks, ground_truth_masks[prefix]):
        test_areas.extend(calculate_area(pred_mask))
        gt_areas.extend(calculate_area(gt_mask))

    # Afficher l'histogramme pour le groupe de préfixe donné
    plot_histogram(test_areas, gt_areas, prefix)
