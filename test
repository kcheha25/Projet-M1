def calculate_area(mask):
    if mask.ndim == 3:
        mask = mask[..., 0]
    _, binary_mask = cv2.threshold(mask, 0.5, 1, cv2.THRESH_BINARY)
    binary_mask = (binary_mask * 255).astype(np.uint8)
    num_objects, object_labels = cv2.connectedComponents(binary_mask)
    areas = []
    for obj in range(1, num_objects):
        area_pixels = np.sum(object_labels == obj)
        area_nm = area_pixels * (resolution_nm_per_pixel ** 2)
        areas.append(area_nm)
    return areas

# Fonction pour normaliser les comptages d'objets
def normalize_counts(counts):
    total_count = sum(counts)
    return [count / total_count for count in counts] if total_count > 0 else counts

# Fonction pour afficher l'histogramme en barres
def plot_histogram(test_areas, gt_areas, prefix):
    surface_bins = np.linspace(0, max(max(test_areas, default=0), max(gt_areas, default=0)), 20)

    fig, axs = plt.subplots(1, 2, figsize=(12, 6))

    counts_pred, bins_pred = np.histogram(test_areas, bins=surface_bins)
    freqs_pred = counts_pred / np.sum(counts_pred) if np.sum(counts_pred) > 0 else counts_pred
    axs[0].bar(bins_pred[:-1], freqs_pred, width=np.diff(bins_pred), color='blue', alpha=0.7, align='edge')
    axs[0].set_title(f"Histogramme des surfaces - Prédit pour {prefix}")
    axs[0].set_xlabel("Surface (nm²)")
    axs[0].set_ylabel("Fréquence normalisée (0-1)")

    counts_gt, bins_gt = np.histogram(gt_areas, bins=surface_bins)
    freqs_gt = counts_gt / np.sum(counts_gt) if np.sum(counts_gt) > 0 else counts_gt
    axs[1].bar(bins_gt[:-1], freqs_gt, width=np.diff(bins_gt), color='green', alpha=0.7, align='edge')
    axs[1].set_title(f"Histogramme des surfaces - Ground Truth pour {prefix}")
    axs[1].set_xlabel("Surface (nm²)")
    axs[1].set_ylabel("Fréquence normalisée (0-1)")

    plt.tight_layout()
    plt.show()