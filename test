import tensorflow as tf
import numpy as np
import matplotlib.pyplot as plt
from skimage import io
import os
import cv2

# Paramètres
resolution_nm_per_pixel = 0.038
image_dir = 'images'
gt_mask_dir = 'masks'

# Charger le modèle U-Net
model = tf.keras.models.load_model('path_to_your_unet_model')

# Fonction pour calculer les aires en nanomètres
def calculate_area(mask):
    # Assurez-vous que le masque est binaire
    if mask.ndim == 3:
        mask = mask[..., 0]  # Convertir en 2D si nécessaire
    _, binary_mask = cv2.threshold(mask, 0.5, 1, cv2.THRESH_BINARY)  # Convertir le masque en binaire
    binary_mask = (binary_mask * 255).astype(np.uint8)  # Convertir en uint8 pour connectedComponents
    
    # Compter les pixels de chaque objet détecté
    num_objects, object_labels = cv2.connectedComponents(binary_mask)
    areas = []
    for obj in range(1, num_objects):  # Ignorer le fond
        area_pixels = np.sum(object_labels == obj)
        area_nm = area_pixels * (resolution_nm_per_pixel ** 2)
        areas.append(area_nm)
    return areas

# Fonction pour normaliser les comptages d'objets
def normalize_counts(counts):
    total_count = sum(counts)
    return [count / total_count for count in counts] if total_count > 0 else counts

# Fonction pour afficher l'histogramme en barres
def plot_histogram(test_areas, gt_areas, prefix):
    fig, axs = plt.subplots(1, 2, figsize=(12, 6))
    axs[0].bar(range(len(test_areas)), normalize_counts(test_areas))
    axs[0].set_title(f"Prédictions du modèle pour le groupe {prefix}")
    axs[0].set_xlabel("Surface en nanomètres")
    axs[0].set_ylabel("Nombre d'objets détectés (normalisé)")

    axs[1].bar(range(len(gt_areas)), normalize_counts(gt_areas))
    axs[1].set_title(f"Masques de vérité terrain pour le groupe {prefix}")
    axs[1].set_xlabel("Surface en nanomètres")
    axs[1].set_ylabel("Nombre d'objets détectés (normalisé)")

    plt.tight_layout()
    plt.show()

# Dictionnaire pour accumuler les aires par préfixe d'image
predicted_areas_by_prefix = {}
gt_areas_by_prefix = {}

# Boucle sur chaque image
for image_file in sorted(os.listdir(image_dir)):
    prefix = image_file[:6]  # Extraire le préfixe (6 premiers caractères)
    
    # Charger l'image et le masque de vérité terrain
    image = io.imread(os.path.join(image_dir, image_file))
    gt_file = image_file.replace('image', 'mask')  # Assumer que le nom du masque correspond au fichier image
    gt_mask = io.imread(os.path.join(gt_mask_dir, gt_file))

    # Vérifier les dimensions et les types de gt_mask
    print(f"Shape of gt_mask for {gt_file}: {gt_mask.shape}, dtype: {gt_mask.dtype}")

    # Assurez-vous que le masque de vérité terrain est binaire
    if gt_mask.ndim == 3:  # Si le masque a des canaux, convertissons-le en 2D
        gt_mask = gt_mask[..., 0]  # Utiliser le premier canal, s'il est en niveaux de gris
    gt_mask = (gt_mask > 0).astype(np.uint8)  # Convertir le masque de vérité terrain en binaire

    # Redimensionner l'image pour correspondre aux dimensions d'entrée du modèle
    image_input = np.expand_dims(image, axis=0)  # Ajouter une dimension de lot

    # Prédire le masque
    pred_mask = model.predict(image_input)[0]  # Extraire la première prédiction du lot

    # Vérification des dimensions du masque prédit
    if pred_mask.ndim == 3:  # S'il est en 3D, convertissons-le en 2D
        pred_mask = pred_mask[..., 0]  # Utiliser le premier canal si nécessaire

    # Diagnostiquer le masque prédit
    print(f"Shape of pred_mask for {image_file}: {pred_mask.shape}, dtype: {pred_mask.dtype}")
    unique_values = np.unique(pred_mask)
    print(f"Unique values in pred_mask for {image_file}: {unique_values}")

    # Calcul des aires pour le masque prédit et le masque de vérité terrain
    pred_areas = calculate_area(pred_mask)
    gt_areas = calculate_area(gt_mask)

    # Affichage des aires calculées
    print(f"Areas for predicted mask for {image_file}: {pred_areas}")
    print(f"Areas for ground truth mask for {gt_file}: {gt_areas}")
    
    # Accumuler les aires pour chaque groupe de préfixe
    if prefix not in predicted_areas_by_prefix:
        predicted_areas_by_prefix[prefix] = []
        gt_areas_by_prefix[prefix] = []
        
    predicted_areas_by_prefix[prefix].extend(pred_areas)
    gt_areas_by_prefix[prefix].extend(gt_areas)

# Afficher les histogrammes pour chaque groupe d'images ayant le même préfixe
for prefix in predicted_areas_by_prefix:
    plot_histogram(predicted_areas_by_prefix[prefix], gt_areas_by_prefix[prefix], prefix)
